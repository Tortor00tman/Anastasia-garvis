<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jarvis ‚Äî Improved Mobile Reactive</title>
<style>
  :root{
    --bg:#070a12; --fg:#e6f1ff; --fg-dim:#9bb3d1;
    --primary:#38bdf8; --accent:#22d3ee; --danger:#ff5470;
    --control-size:56px; --gap:12px; --max-core:520px;
  }

  /* Basic reset */
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; -webkit-font-smoothing:antialiased}
  body{
    background: radial-gradient(1200px 800px at 50% 40%, #0d1322 0%, var(--bg) 60%, #05070c 100%);
    color:var(--fg); overflow:hidden;
  }

  /* Layout */
  .wrap{height:100%; display:flex; align-items:center; justify-content:center; padding:18px; position:relative}
  .core{width:min(88vw,var(--max-core)); aspect-ratio:1/1; position:relative; display:grid; place-items:center; touch-action:none; -webkit-tap-highlight-color:transparent}

  /* Decorative backdrops (subtle) */
  .backdrop{position:fixed; inset:0; pointer-events:none; z-index:0}
  .grid{position:absolute; inset:-200vmax; opacity:.06; background-image:
    linear-gradient(to right, rgba(255,255,255,.04) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(255,255,255,.04) 1px, transparent 1px); background-size:48px 48px}
  .noise{position:fixed; inset:0; opacity:.03; pointer-events:none; mix-blend-mode:soft-light; z-index:1;
    background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="140" height="140"><filter id="n"><feTurbulence baseFrequency="0.8" numOctaves="2" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23n)"/></svg>')}

  /* Orb and rings */
  .aura{position:absolute; inset:0; border-radius:50%; filter:blur(36px) saturate(130%); pointer-events:none; z-index:2;
    background: conic-gradient(rgba(56,189,248,.10), rgba(167,139,250,.08), rgba(34,211,238,.08), rgba(56,189,248,.08))}
  .rings{position:absolute; inset:0; border-radius:50%; pointer-events:none; z-index:3; mix-blend-mode:screen; opacity:.7;
    background: radial-gradient(closest-side, rgba(56,189,248,.06), transparent 60%), radial-gradient(closest-side, rgba(167,139,250,.05), transparent 60%)}
  .orb{position:relative; width:70%; aspect-ratio:1/1; border-radius:50%; z-index:4;
      background:
        radial-gradient(circle at 50% 35%, rgba(255,255,255,.14), rgba(255,255,255,.02) 40%),
        radial-gradient(circle at 50% 65%, rgba(34,211,238,.20), rgba(56,189,248,.12));
      box-shadow:0 0 36px rgba(56,189,248,.2), inset 0 0 44px rgba(167,139,250,.12);
      transition:transform .18s cubic-bezier(.2,.9,.3,1); display:grid; place-items:center; overflow:visible}

  .orb::before{content:""; position:absolute; inset:12%; border-radius:50%; border:1.4px solid rgba(168,189,255,.12); box-shadow:0 0 18px rgba(56,189,248,.16); mask: radial-gradient(circle at 50% 50%, transparent 55%, #000 56%)}

  /* particles */
  .field{position:absolute; inset:-6vmin; pointer-events:none; z-index:5}
  .particle{position:absolute; border-radius:50%; pointer-events:none; background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(56,189,248,0) 70%); opacity:.85; filter:drop-shadow(0 0 6px rgba(56,189,248,.4))}

  /* HUD and controls */
  .hud{position:absolute; inset:auto 0 -92px 0; display:flex; flex-direction:column; align-items:center; gap:8px; z-index:6; text-align:center; color:var(--fg-dim)}
  .title{font-weight:700; font-size:12px; color:#a6c5ff; letter-spacing:.12em; text-transform:uppercase}
  .status{font-weight:700; font-size:clamp(15px,3.2vw,20px); color:var(--fg)}
  .hint{font-size:13px; opacity:.85; max-width:86%}

  .controls{position:fixed; left:50%; bottom:18px; transform:translateX(-50%); display:flex; gap:var(--gap); z-index:8; padding:6px; border-radius:14px; background:rgba(255,255,255,0.02); backdrop-filter:blur(8px)}
  button.btn{min-width:var(--control-size); height:var(--control-size); border-radius:12px; border:0; background:linear-gradient(180deg, rgba(56,189,248,.18), rgba(56,189,248,.10)); color:var(--fg); font-weight:700; display:inline-flex; align-items:center; justify-content:center; gap:8px; cursor:pointer; box-shadow:0 8px 18px rgba(3,7,18,.6); padding:10px}
  .btn.secondary{background:linear-gradient(180deg, rgba(167,139,250,.12), rgba(167,139,250,.06))}
  .btn.danger{background:linear-gradient(180deg, rgba(255,84,112,.14), rgba(255,84,112,.06))}
  .btn:disabled{opacity:.5; cursor:not-allowed}
  .visually-hidden{position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap}

  /* canvas */
  canvas#viz{position:absolute; inset:-12% -12% -12% -12%; width:124%; height:124%; pointer-events:none; z-index:1; filter:contrast(110%) saturate(110%)}

  /* settings panel */
  .settings{position:fixed; right:12px; top:12px; z-index:9; background:rgba(0,0,0,.28); padding:10px; border-radius:10px; backdrop-filter:blur(6px); color:var(--fg-dim); font-size:13px}
  .settings label{display:flex; align-items:center; gap:8px}
  input[type=range]{width:120px}

  @media (max-width:640px){ :root{--control-size:50px} .hud{inset:auto 0 -76px 0} .hint{display:none} .settings{right:8px; top:8px} }

  @media (prefers-reduced-motion: reduce){
    .aura, .rings, .orb, .particle, canvas#viz{transition:none!important; animation:none!important}
  }
</style>
</head>
<body>
  <div class="backdrop"><div class="grid"></div></div>
  <div class="noise" aria-hidden="true"></div>

  <main class="wrap" aria-live="polite">
    <section class="core" id="core" role="application" aria-label="Jarvis core visual">
      <div class="aura" id="aura" aria-hidden="true"></div>
      <canvas id="viz" aria-hidden="true"></canvas>
      <div class="rings" id="rings" aria-hidden="true"></div>

      <div class="orb" id="orb" role="img" aria-label="Reactive orb">
        <div class="field" id="field" aria-hidden="true"></div>
      </div>

      <div class="hud" aria-hidden="false">
        <div class="title">–ü—Ä–æ—î–∫—Ç ¬´Jarvis¬ª</div>
        <div class="status" id="status">–ì–æ—Ç–æ–≤–∏–π. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–ü–æ—á–∞—Ç–∏¬ª.</div>
        <div class="hint" id="hint">–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–ü–æ—á–∞—Ç–∏¬ª ‚Üí –¥–æ–∑–≤–æ–ª—ñ—Ç—å –º—ñ–∫—Ä–æ—Ñ–æ–Ω ‚Üí –≥–æ–≤–æ—Ä—ñ—Ç—å. –Ø–∫—â–æ –Ω–µ–º–∞—î –¥–æ–∑–≤–æ–ª—É ‚Äî —É–≤—ñ–º–∫–Ω—ñ—Ç—å —Å–∏–º—É–ª—è—Ü—ñ—é.</div>
      </div>
    </section>
  </main>

  <div class="controls" role="toolbar" aria-label="–ö–µ—Ä—É–≤–∞–Ω–Ω—è">
    <button class="btn" id="btnStart" title="–ü–æ—á–∞—Ç–∏">
      ‚ñ∂
      <span class="visually-hidden">–ü–æ—á–∞—Ç–∏</span>
    </button>
    <button class="btn secondary" id="btnMute" disabled title="–ó–∞–≥–ª—É—à–∏—Ç–∏">
      üîá
      <span class="visually-hidden">–ó–∞–≥–ª—É—à–∏—Ç–∏</span>
    </button>
    <button class="btn danger" id="btnStop" disabled title="–ó—É–ø–∏–Ω–∏—Ç–∏">
      ‚ñ†
      <span class="visually-hidden">–ó—É–ø–∏–Ω–∏—Ç–∏</span>
    </button>
  </div>

  <aside class="settings" aria-hidden="false">
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px">
      <label style="font-weight:700;color:var(--fg)">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</label>
    </div>
    <div style="display:flex;flex-direction:column;gap:6px">
      <label title="–ß—É—Ç–ª–∏–≤—ñ—Å—Ç—å">
        –ß—É—Ç–ª–∏–≤—ñ—Å—Ç—å
        <input id="sensitivity" type="range" min="0.6" max="4" step="0.1" value="2.6">
      </label>
      <label title="–ó–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è">
        –ó–≥–ª–∞–¥–∂—É–≤–∞–Ω–Ω—è
        <input id="smoothing" type="range" min="0" max="0.98" step="0.02" value="0.86">
      </label>
      <label>
        <input id="particlesToggle" type="checkbox" checked> –ß–∞—Å—Ç–∏–Ω–∫–∏
      </label>
      <label>
        <input id="simulateToggle" type="checkbox"> –°–∏–º—É–ª—è—Ü—ñ—è (–±–µ–∑ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞)
      </label>
    </div>
  </aside>

<script>
/* Improved Jarvis ‚Äî more robust handling, simulation fallback, debug-safe */
(() => {
  // Elements
  const statusEl = document.getElementById('status');
  const hintEl = document.getElementById('hint');
  const orb = document.getElementById('orb');
  const rings = document.getElementById('rings');
  const field = document.getElementById('field');
  const core = document.getElementById('core');
  const canvas = document.getElementById('viz');
  const ctx = canvas.getContext('2d', { alpha:true });

  const btnStart = document.getElementById('btnStart');
  const btnMute = document.getElementById('btnMute');
  const btnStop = document.getElementById('btnStop');

  const sensitivityInput = document.getElementById('sensitivity');
  const smoothingInput = document.getElementById('smoothing');
  const particlesToggle = document.getElementById('particlesToggle');
  const simulateToggle = document.getElementById('simulateToggle');

  // Audio/visual state
  let audioCtx = null, analyser = null, sourceNode = null, mediaStream = null;
  let rafId = null;
  let started = false, muted = false;
  let simulate = false;
  let smoothingFactor = parseFloat(smoothingInput.value) || 0.86;
  let sensitivity = parseFloat(sensitivityInput.value) || 2.6;
  let levelSmoothed = 0;

  // Transform state (avoid concatenation)
  let tx = 0, ty = 0, targetTx = 0, targetTy = 0;

  // Resize canvas to element size (DPR aware)
  function fitCanvas(){
    const rect = core.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * 1.28 * ratio));
    canvas.height = Math.max(1, Math.floor(rect.height * 1.28 * ratio));
  }

  // Particle seeding adaptive
  function particleCount(){
    const w = window.innerWidth;
    if(!particlesToggle.checked) return 0;
    if(w < 420) return 10;
    if(w < 640) return 18;
    if(w < 900) return 28;
    return 40;
  }

  function seedParticles(){
    field.innerHTML = '';
    const rect = field.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    const cnt = particleCount();
    for(let i=0;i<cnt;i++){
      const d=document.createElement('div');
      d.className='particle';
      const angle=Math.random()*Math.PI*2;
      const radius=(rect.width/2)*(0.68 + Math.random()*0.32);
      const x = cx + Math.cos(angle)*radius;
      const y = cy + Math.sin(angle)*radius;
      const size = Math.round(3 + Math.random()*6);
      d.style.left = `${x}px`; d.style.top = `${y}px`; d.style.width = d.style.height = `${size}px`;
      d.style.opacity = (0.5 + Math.random()*0.5).toFixed(2);
      field.appendChild(d);
    }
  }

  // Debounced resize
  let rTimer = null;
  function handleResize(){
    if(rTimer) clearTimeout(rTimer);
    rTimer = setTimeout(()=>{ fitCanvas(); seedParticles(); }, 80);
  }
  window.addEventListener('resize', handleResize, { passive:true });

  // Init visuals
  fitCanvas();
  seedParticles();

  // Audio init in user gesture
  async function initAudio(){
    // HTTPS check
    if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
      statusEl.textContent = '–ü–æ—Ç—Ä—ñ–±–µ–Ω HTTPS –∞–±–æ localhost –¥–ª—è –¥–æ—Å—Ç—É–ø—É –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞.';
      return false;
    }

    try {
      // Request microphone
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:true, noiseSuppression:true }, video:false });

      // Create AudioContext lazily (some browsers require user gesture)
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();

      // create nodes
      sourceNode = audioCtx.createMediaStreamSource(mediaStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = smoothingFactor;
      sourceNode.connect(analyser);

      // Resume if suspended (iOS/Chrome)
      if(audioCtx.state === 'suspended'){
        try { await audioCtx.resume(); } catch(e){ console.warn('resume failed', e); }
      }

      return true;
    } catch (err) {
      console.error('getUserMedia error', err);
      statusEl.textContent = '–ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞: ' + (err && err.name ? err.name : String(err));
      return false;
    }
  }

  // Compute RMS level or return simulated idle
  let timeDomain = null;
  function measureLevel(){
    if(simulate || !analyser){
      // idle pulsation simulation when not listening
      const t = performance.now() / 1000;
      return 0.04 + Math.abs(Math.sin(t*1.8)) * 0.07;
    }
    if(!timeDomain || timeDomain.length !== analyser.fftSize) timeDomain = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(timeDomain);
    let sum=0;
    for(let i=0;i<timeDomain.length;i++){
      const v = (timeDomain[i] - 128) / 128;
      sum += v*v;
    }
    return Math.sqrt(sum / timeDomain.length); // ~0..1 small values
  }

  // Frequency data (optional, for visuals)
  let freqData = null;

  // Animation loop
  let last = performance.now();
  function render(now){
    rafId = requestAnimationFrame(render);
    const dt = (now - last)/1000; last = now;

    // smooth pointer translate interpolation
    tx += (targetTx - tx) * Math.min(0.18, 8*dt);
    ty += (targetTy - ty) * Math.min(0.18, 8*dt);

    // level
    const rawLevel = measureLevel();
    const scaled = Math.min(1, rawLevel * (sensitivity)); // apply sensitivity
    // smoothing to avoid jitter
    levelSmoothed = (levelSmoothed * (1 - 0.12)) + (scaled * 0.12);

    // apply transforms (no concatenation)
    const scale = 1 + levelSmoothed * 0.08;
    orb.style.transform = `translate(${Math.round(tx)}px, ${Math.round(ty)}px) scale(${scale})`;
    rings.style.transform = `translate(${Math.round(tx*0.55)}px, ${Math.round(ty*0.55)}px) scale(${1 + levelSmoothed*0.14})`;
    rings.style.opacity = String(0.58 + levelSmoothed * 0.42);

    // draw canvas visuals (safe even if analyser missing)
    const w = canvas.width, h = canvas.height, cx = w/2, cy = h/2;
    ctx.clearRect(0,0,w,h);

    // draw layered neon rings
    const layers = 3;
    for(let i=0;i<layers;i++){
      const R = Math.min(w,h) * (0.18 + i*0.12 + levelSmoothed*0.03);
      ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.lineWidth = 2 * (window.devicePixelRatio || 1);
      const alpha = Math.max(0.02, 0.18 - i*0.03 + levelSmoothed*0.10);
      ctx.strokeStyle = `rgba(${160+i*18}, ${220-i*18}, 255, ${alpha})`;
      ctx.shadowColor = 'rgba(56,189,248,0.35)';
      ctx.shadowBlur = 12 * (window.devicePixelRatio || 1);
      ctx.stroke();
    }

    // dynamic low-poly fill
    if(analyser && !simulate){
      if(!freqData || freqData.length !== analyser.frequencyBinCount) freqData = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(freqData);
    }
    const bins = 36;
    const baseR = Math.min(w,h) * (0.22 + levelSmoothed*0.04);
    ctx.beginPath();
    for(let i=0;i<bins;i++){
      const a = (i/bins)*Math.PI*2 + now*0.0006;
      const mag = (analyser && freqData) ? ((freqData[i]||0)/255) : 0;
      const r = baseR + (mag * 34 * (window.devicePixelRatio || 1));
      const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle = `rgba(56,189,248, ${0.06 + levelSmoothed*0.12})`;
    ctx.fill();

    // soft glow
    const glowR = baseR + 44*(window.devicePixelRatio || 1) + levelSmoothed*46*(window.devicePixelRatio || 1);
    const grad = ctx.createRadialGradient(cx,cy,baseR*0.28,cx,cy,glowR);
    grad.addColorStop(0, `rgba(167,139,250, ${0.08 + levelSmoothed*0.14})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(cx,cy,glowR,0,Math.PI*2); ctx.fill();

    // small dots
    const dots = 10;
    for(let i=0;i<dots;i++){
      const a = (i/dots)*Math.PI*2 + now*0.0008*(1+i*0.02);
      const r = baseR + 20*(window.devicePixelRatio||1) + Math.sin(now*0.002 + i)*4*(window.devicePixelRatio||1) + levelSmoothed*8*(window.devicePixelRatio||1);
      const x = cx + Math.cos(a)*r, y = cy + Math.sin(a)*r;
      ctx.beginPath();
      ctx.arc(x,y, 2.0*(window.devicePixelRatio||1) + levelSmoothed*1.2, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255, ${0.64 + Math.sin(now*0.004+i)*0.18})`;
      ctx.shadowColor = 'rgba(56,189,248,0.48)';
      ctx.shadowBlur = 10*(window.devicePixelRatio||1);
      ctx.fill();
    }
  }

  // Controls: start/stop/mute
  btnStart.addEventListener('click', async () => {
    // If already started and audio context suspended -> try resume
    btnStart.disabled = true;
    statusEl.textContent = '–ü–æ—á–∏–Ω–∞—î–º–æ...';
    simulate = simulateToggle.checked;

    if(!simulate){
      const ok = await initAudio();
      if(!ok){
        // enable simulate fallback
        statusEl.textContent = '–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –º—ñ–∫—Ä–æ—Ñ–æ–Ω ‚Äî —É–≤—ñ–º–∫–Ω—ñ—Ç—å "–°–∏–º—É–ª—è—Ü—ñ—è" –∞–±–æ –¥–∞–π—Ç–µ –¥–æ–∑–≤—ñ–ª.';
        btnStart.disabled = false;
        return;
      }
    } else {
      // simulation mode (no mic)
      if(audioCtx && audioCtx.state === 'suspended'){
        try { await audioCtx.resume(); } catch(e){ /* ignore */ }
      }
    }

    started = true;
    muted = false;
    btnMute.disabled = false; btnStop.disabled = false;
    btnStart.disabled = true;
    statusEl.textContent = simulate ? '–°–∏–º—É–ª—è—Ü—ñ—è: –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –∞–∫—Ç–∏–≤–Ω–∞.' : '–°–ª—É—Ö–∞—é‚Ä¶ –ì–æ–≤–æ—Ä—ñ—Ç—å.';
    startRendering();
  });

  btnMute.addEventListener('click', () => {
    if(!started) return;
    muted = !muted;
    btnMute.textContent = muted ? 'üîà' : 'üîá';
    statusEl.textContent = muted ? '–ú—ñ–∫—Ä–æ—Ñ–æ–Ω –∑–∞–≥–ª—É—à–µ–Ω–æ.' : (simulate ? '–°–∏–º—É–ª—è—Ü—ñ—è: –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –∞–∫—Ç–∏–≤–Ω–∞.' : '–°–ª—É—Ö–∞—é‚Ä¶ –ì–æ–≤–æ—Ä—ñ—Ç—å.');
  });

  btnStop.addEventListener('click', () => {
    stopEverything();
  });

  // Start RAF
  function startRendering(){
    if(rafId) cancelAnimationFrame(rafId);
    // set smoother analyser smoothing value to current config
    if(analyser) analyser.smoothingTimeConstant = smoothingFactor;
    last = performance.now();
    rafId = requestAnimationFrame(render);
  }

  // Stop audio + visuals
  function stopEverything(){
    // stop stream tracks
    try {
      if(mediaStream) mediaStream.getTracks().forEach(t => t.stop());
    } catch(e){ console.warn(e); }
    mediaStream = null;
    try{ if(sourceNode) sourceNode.disconnect(); } catch(e){}
    sourceNode = null;
    try{ if(analyser) analyser.disconnect(); } catch(e){}
    analyser = null;
    try{ if(audioCtx) audioCtx.close(); } catch(e){}
    audioCtx = null;

    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;
    started = false; muted = false;
    btnStart.disabled = false; btnMute.disabled = true; btnStop.disabled = true;
    statusEl.textContent = '–ó—É–ø–∏–Ω–µ–Ω–æ. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–ü–æ—á–∞—Ç–∏¬ª.';
    // visual reset
    orb.style.transform = `translate(0px, 0px) scale(1)`;
    rings.style.transform = `translate(0px, 0px) scale(1)`;
    rings.style.opacity = '0.6';
  }

  // Pointer parallax (throttled)
  let lastPointer = 0;
  window.addEventListener('pointermove', (e) => {
    const now = performance.now();
    if(now - lastPointer < 12) return;
    lastPointer = now;
    const r = core.getBoundingClientRect();
    const x = (e.clientX - (r.left + r.width/2)) / r.width;
    const y = (e.clientY - (r.top + r.height/2)) / r.height;
    const sensitivityPx = Math.max(6, r.width * 0.02);
    targetTx = x * sensitivityPx;
    targetTy = y * sensitivityPx;
  }, { passive:true });

  // keyboard accessibility: space / enter starts
  window.addEventListener('keydown', (e) => {
    if(e.key === ' ' || e.key === 'Enter'){
      const tag = document.activeElement && document.activeElement.tagName;
      if(tag !== 'INPUT' && tag !== 'TEXTAREA'){
        e.preventDefault();
        if(!started) btnStart.click();
      }
    }
  }, { passive:false });

  // settings handlers
  sensitivityInput.addEventListener('input', (e) => {
    sensitivity = parseFloat(e.target.value) || 2.6;
  });
  smoothingInput.addEventListener('input', (e) => {
    smoothingFactor = parseFloat(e.target.value) || 0.86;
    if(analyser) analyser.smoothingTimeConstant = smoothingFactor;
  });
  particlesToggle.addEventListener('change', seedParticles);
  simulateToggle.addEventListener('change', (e) => {
    simulate = e.target.checked;
    if(simulate){
      // if currentg transforms)
  let baseScale = 1;
  let translateX = 0, translateY = 0;

  // Particle config (adaptive)
  function particleCountBySize(){
    const w = window.innerWidth;
    if(w < 420) return 10;
    if(w < 640) return 18;
    if(w < 900) return 28;
    return 40;
  }

  // Seed particles
  function seedParticles(){
    field.innerHTML = '';
    const count = particleCountBySize();
    const rect = field.getBoundingClientRect();
    const cx = rect.width / 2;
    const cy = rect.height / 2;
    for(let i=0;i<count;i++){
      const p = document.createElement('div');
      p.className = 'particle';
      const angle = Math.random() * Math.PI * 2;
      const radius = (rect.width/2) * (0.68 + Math.random()*0.36);
      const x = cx + Math.cos(angle) * radius;
      const y = cy + Math.sin(angle) * radius;
      p.style.left = `${x}px`; p.style.top = `${y}px`;
      const size = Math.round(3 + Math.random()*6);
      p.style.width = p.style.height = `${size}px`;
      p.style.opacity = (0.6 + Math.random()*0.4).toFixed(2);
      // CSS variables used by animations (if active)
      p.style.setProperty('--dx', `${(Math.random()*50-25).toFixed(1)}px`);
      p.style.setProperty('--dy', `${(Math.random()*50-25).toFixed(1)}px`);
      field.appendChild(p);
    }
  }

  // Canvas fit with DPR handling, debounced
  function fitCanvas(){
    const rect = core.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * 1.2 * ratio));
    canvas.height = Math.max(1, Math.floor(rect.height * 1.2 * ratio));
  }

  let resizeTimer;
  function onResize(){
    if(resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      fitCanvas();
      seedParticles();
    }, 120);
  }
  window.addEventListener('resize', onResize, { passive:true });

  // Init visuals
  fitCanvas();
  seedParticles();

  // Audio init (called on user gesture)
  async function initMic(){
    try{
      // secure context check
      if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
        statusEl.textContent = '–ü–æ—Ç—Ä—ñ–±–µ–Ω HTTPS –∞–±–æ localhost –¥–ª—è –¥–æ—Å—Ç—É–ø—É –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞.';
        statusEl.style.color = 'var(--fg-dim)';
        return false;
      }

      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true }, video:false });

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaStreamSource(mediaStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.86;
      sourceNode.connect(analyser);

      // Mobile browsers often suspend AudioContext until resumed on gesture
      if(audioCtx.state === 'suspended') await audioCtx.resume();

      statusEl.textContent = '–°–ª—É—Ö–∞—é‚Ä¶ –ì–æ–≤–æ—Ä—ñ—Ç—å.';
      statusEl.style.color = '';
      btnMute.disabled = false;
      btnStop.disabled = false;
      started = true;
      return true;
    }catch(err){
      statusEl.textContent = '–ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞: ' + (err && err.message ? err.message : err);
      statusEl.style.color = 'var(--danger)';
      return false;
    }
  }

  // RMS level calc
  let byteTimeArray = null;
  function getLevel(){
    if(!analyser){
      return 0;
    }
    if(!byteTimeArray || byteTimeArray.length !== analyser.fftSize) byteTimeArray = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(byteTimeArray);
    let sum = 0;
    for(let i=0;i<byteTimeArray.length;i++){
      const v = (byteTimeArray[i] - 128) / 128;
      sum += v*v;
    }
    return Math.sqrt(sum / byteTimeArray.length); // 0..1 (small)
  }

  // Frequency data (for spectrum)
  let freqArray = null;

  // Animation loop
  let lastTime = performance.now();
  function loop(now){
    rafId = requestAnimationFrame(loop);
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    // canvas clear
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    const cx = w/2, cy = h/2;

    // compute level with smoothing
    let level = 0;
    if(analyser && !muted){
      level = getLevel() * 3.0; // sensitivity boost
      if(level > 1) level = 1;
    }

    // apply transforms based on level and pointer translate
    baseScale = 1 + level * 0.08;
    const ringScale = 1 + level * 0.14;
    // set transforms (no concatenation)
    orb.style.transform = `translate(${translateX}px, ${translateY}px) scale(${baseScale})`;
    rings.style.transform = `translate(${translateX*0.6}px, ${translateY*0.6}px) scale(${ringScale})`;
    rings.style.opacity = String(0.6 + level * 0.4);

    // Draw neon rings (3 layers)
    const layers = 3;
    for(let i=0;i<layers;i++){
      const R = Math.min(w,h) * (0.18 + i*0.12 + level*0.04);
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.lineWidth = 2 * (window.devicePixelRatio || 1);
      const alpha = Math.max(0.02, 0.18 - i*0.03 + level*0.1);
      ctx.strokeStyle = `rgba(${160+i*20}, ${220-i*20}, 255, ${alpha})`;
      ctx.shadowColor = 'rgba(56,189,248,0.35)';
      ctx.shadowBlur = 12 * (window.devicePixelRatio || 1);
      ctx.stroke();
    }

    // Spectrum polygon (low-poly feel)
    if(analyser){
      if(!freqArray || freqArray.length !== analyser.frequencyBinCount) freqArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(freqArray);
    }
    const bins = Math.min(48, analyser ? analyser.frequencyBinCount : 48);
    const baseR = Math.min(w,h) * (0.22 + level*0.04);
    ctx.beginPath();
    for(let i=0;i<bins;i++){
      const a = (i / bins) * Math.PI * 2 + now*0.0006;
      const mag = analyser ? (freqArray[i] || 0)/255 : 0;
      const r = baseR + (mag * 32 * (window.devicePixelRatio || 1));
      const x = cx + Math.cos(a) * r;
      const y = cy + Math.sin(a) * r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle = `rgba(56,189,248, ${0.07 + level*0.10})`;
    ctx.fill();

    // Glow
    const glowR = baseR + 36 * (window.devicePixelRatio || 1) + level * 46 * (window.devicePixelRatio || 1);
    const grad = ctx.createRadialGradient(cx, cy, baseR*0.28, cx, cy, glowR);
    grad.addColorStop(0, `rgba(167,139,250, ${0.09 + level*0.14})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();

    // Small dots along ring
    const dots = 10;
    for(let i=0;i<dots;i++){
      const a = (i/dots)*Math.PI*2 + now*0.0008*(1+i*0.02);
      const r = baseR + 20*(window.devicePixelRatio || 1) + Math.sin(now*0.002 + i)*4*(window.devicePixelRatio || 1) + level*8*(window.devicePixelRatio || 1);
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      ctx.beginPath();
      ctx.arc(x,y, 2.0*(window.devicePixelRatio || 1) + level*1.2, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255, ${0.65 + Math.sin(now*0.004+i)*0.2})`;
      ctx.shadowColor = 'rgba(56,189,248,0.48)';
      ctx.shadowBlur = 10*(window.devicePixelRatio || 1);
      ctx.fill();
    }
  }

  // Start loop safely
  function startVisualLoop(){
    if(rafId) cancelAnimationFrame(rafId);
    lastTime = performance.now();
    rafId = requestAnimationFrame(loop);
  }

  // Stop visuals and audio teardown
  function stopAll(){
    if(mediaStream){
      mediaStream.getTracks().forEach(t => t.stop());
      mediaStream = null;
    }
    if(sourceNode){ try{ sourceNode.disconnect(); }catch(e){} sourceNode = null; }
    if(analyser){ analyser.disconnect(); analyser = null; }
    if(audioCtx){ try{ audioCtx.close(); }catch(e){} audioCtx = null; }
    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;
    started = false;
    muted = false;
    btnStart.disabled = false;
    btnMute.disabled = true; btnMute.setAttribute('aria-pressed', 'false');
    btnStop.disabled = true;
    statusEl.textContent = '–ó—É–ø–∏–Ω–µ–Ω–æ. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–ü–æ—á–∞—Ç–∏¬ª, —â–æ–± –∑–Ω–æ–≤—É –∞–∫—Ç–∏–≤—É–≤–∞—Ç–∏.';
    orb.style.transform = `translate(0px, 0px) scale(1)`;
    rings.style.transform = `translate(0px, 0px) scale(1)`;
    rings.style.opacity = '0.6';
  }

  // Button handlers
  btnStart.addEventListener('click', async (e) => {
    btnStart.disabled = true;
    statusEl.textContent = '–ó–∞–ø–∏—Ç –¥–æ—Å—Ç—É–ø—É –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞‚Ä¶';
    const ok = await initMic();
    if(ok){
      btnStart.setAttribute('aria-pressed','true');
      startVisualLoop();
    }else{
      btnStart.disabled = false;
    }
  });

  btnMute.addEventListener('click', () => {
    if(!started) return;
    muted = !muted;
    btnMute.setAttribute('aria-pressed', String(muted));
    btnMute.disabled = false;
    btnMute.querySelector('.visually-hidden').textContent = muted ? '–£–≤—ñ–º–∫–Ω—É—Ç–∏' : '–ó–∞–≥–ª—É—à–∏—Ç–∏';
    statusEl.textContent = muted ? '–ú—ñ–∫—Ä–æ—Ñ–æ–Ω –∑–∞–≥–ª—É—à–µ–Ω–æ.' : '–°–ª—É—Ö–∞—é‚Ä¶ –ì–æ–≤–æ—Ä—ñ—Ç—å.';
  });

  btnStop.addEventListener('click', () => {
    stopAll();
  });

  // keyboard accessibility
  window.addEventListener('keydown', (e) => {
    if(e.key === ' ' || e.key === 'Enter'){
      // if focus is not in input element, treat as play/pause start
      const tag = document.activeElement && document.activeElement.tagName;
      if(tag !== 'INPUT' && tag !== 'TEXTAREA'){
        e.preventDefault();
        if(!started) btnStart.click();
      }
    }
  }, { passive:false });

  // Pointer move for subtle parallax - optimized, throttled
  let pointerThrottle = 0;
  window.addEventListener('pointermove', (e) => {
    const now = performance.now();
    if(now - pointerThrottle < 16) return; // ~60fps cap
    pointerThrottle = now;
    const r = core.getBoundingClientRect();
    const x = (e.clientX - (r.left + r.width/2)) / r.width;
    const y = (e.clientY - (r.top + r.height/2)) / r.height;
    // scale sensitivity based on size
    const sensitivity = Math.min(20, r.width * 0.02);
    translateX = Math.round(x * sensitivity);
    translateY = Math.round(y * sensitivity);
  }, { passive:true }); || 1;
    const rect = core.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * 1.2 * ratio);
    canvas.height = Math.floor(rect.height * 1.2 * ratio);
  }

  window.addEventListener('resize', () => {
    fitCanvas();
    seedParticles(36);
  });

  fitCanvas();
  seedParticles(36);

  // –ê—É–¥—ñ–æ-–ø–∞–π–ø–ª–∞–π–Ω
  async function initMic(){
    try{
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true }, video:false });
    }catch(err){
      statusEl.textContent = '–ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞: ' + (err.message || err.name);
      statusEl.style.color = 'var(--danger)';
      return;
    }

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sourceNode = audioCtx.createMediaStreamSource(mediaStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.85;

    sourceNode.connect(analyser);

    // iOS requires resume on user gesture; –∫–Ω–æ–ø–∫–∞ –≤–∂–µ –±—É–ª–∞ –Ω–∞—Ç–∏—Å–Ω—É—Ç–∞
    if(audioCtx.state === 'suspended'){
      await audioCtx.resume();
    }

    statusEl.textContent = '–°–ª—É—Ö–∞—é‚Ä¶ –ì–æ–≤–æ—Ä—ñ—Ç—å.';
    btnMute.disabled = false;
    btnStop.disabled = false;
    started = true;
    loop();
  }

  // –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ —Ä—ñ–≤–Ω—è –≥—É—á–Ω–æ—Å—Ç—ñ (RMS)
  const dataArray = new Uint8Array(512);
  function getLevel(){
    analyser.getByteTimeDomainData(dataArray);
    // –Ω–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è [0..255] -> [-1..1]
    let sum = 0;
    for(let i=0; i<dataArray.length; i++){
      const v = (dataArray[i] - 128) / 128;
      sum += v*v;
    }
    const rms = Math.sqrt(sum / dataArray.length);
    return rms; // ~0..1
  }

  // –ì–æ–ª–æ–≤–Ω–∏–π —Ü–∏–∫–ª –∞–Ω—ñ–º–∞—Ü—ñ–π
  let t = 0;
  function loop(){
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);

    t += 0.016;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const ratio = window.devicePixelRatio || 1;
    const w = canvas.width, h = canvas.height;
    const cx = w/2, cy = h/2;

    let level = muted ? 0 : (analyser ? getLevel() : 0);
    // –†–æ–±–∏–º–æ —Ä–µ–∞–∫—Ü—ñ—é —Ç—Ä–æ—Ö–∏ —á—É—Ç–ª–∏–≤—ñ—à–æ—é
    level = Math.min(1, level * 3.2);

    // –í—ñ–∑—É–∞–ª: –ø—É–ª—å—Å–∞—Ü—ñ—è –æ—Ä–±—ñ—Ç–∏ —Ç–∞ –∫—ñ–ª–µ—Ü—å
    const scale = 1 + level * 0.08;
    const ringPulse = 1 + level * 0.15;

    orb.style.transform = `scale(${scale})`;
    rings.style.transform = `scale(${ringPulse})`;
    rings.style.opacity = String(0.6 + level * 0.4);

    // –ù–µ–æ–Ω–æ–≤—ñ —Ö–≤–∏–ª—ñ + —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–µ –∫—ñ–ª—å—Ü–µ
    const layers = 3;
    for(let i=0;i<layers;i++){
      const R = Math.min(w,h) * (0.18 + i*0.12 + level*0.05);
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.lineWidth = 2 * ratio;
      ctx.strokeStyle = `rgba(${160+i*20}, ${220-i*20}, 255, ${0.18 - i*0.04 + level*0.12})`;
      ctx.shadowColor = 'rgba(56,189,248,0.35)';
      ctx.shadowBlur = 24 * ratio;
      ctx.stroke();
    }

    // –î–∏–Ω–∞–º—ñ—á–Ω—ñ ‚Äú–ø–µ–ª—é—Å—Ç–∫–∏‚Äù —Å–ø–µ–∫—Ç—Ä—É (low-poly —Å—Ç–∏–ª—å)
    const bins = 48;
    const freqData = new Uint8Array(analyser ? analyser.frequencyBinCount : 0);
    if(analyser){
      analyser.getByteFrequencyData(freqData);
    }
    const baseR = Math.min(w,h) * (0.22 + level*0.04);
    ctx.beginPath();
    for(let i=0;i<bins;i++){
      const a = (i / bins) * Math.PI * 2 + t*0.6;
      const mag = analyser ? (freqData[i] || 0)/255 : 0;
      const r = baseR + (mag * 34 * ratio);
      const x = cx + Math.cos(a) * r;
      const y = cy + Math.sin(a) * r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle = `rgba(56,189,248, ${0.08 + level*0.10})`;
    ctx.fill();

    // –°–≤—ñ—Ç–ª–æ–≤–∏–π ‚Äú–¥–æ—Ç—ñ–∫‚Äù
    const glowR = baseR + 40 * ratio + level * 60 * ratio;
    const grad = ctx.createRadialGradient(cx, cy, baseR*0.3, cx, cy, glowR);
    grad.addColorStop(0, `rgba(167,139,250, ${0.10 + level*0.15})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();

    // –ú–∞–ª–µ–Ω—å–∫—ñ –ø—É–ª—å—Å—É—é—á—ñ —Ç–æ—á–∫–∏ –Ω–∞ –∫—ñ–ª—å—Ü—ñ
    const dots = 12;
    for(let i=0;i<dots;i++){
      const a = (i/dots)*Math.PI*2 + t*(0.8 + i*0.02);
      const r = baseR + 20*ratio + Math.sin(t*1.6 + i)*6*ratio + level*10*ratio;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      ctx.beginPath();
      ctx.arc(x,y, 2.2*ratio + level*1.2, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255, ${0.7 + Math.sin(t*2+i)*0.25})`;
      ctx.shadowColor = 'rgba(56,189,248,0.55)';
      ctx.shadowBlur = 16*ratio;
      ctx.fill();
    }
  }

  // –ö–Ω–æ–ø–∫–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è
  btnStart.addEventListener('click', async () => {
    if(started){
      // –Ø–∫—â–æ –∞—É–¥—ñ–æ-–∫–æ–Ω—Ç–µ–∫—Å—Ç –∑–∞–º–æ—Ä–æ–∂–µ–Ω–∏–π (iOS), —Å–ø—Ä–æ–±–∞ –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏
      if(audioCtx && audioCtx.state === 'suspended'){ await audioCtx.resume(); }
      statusEl.textContent = '–°–ª—É—Ö–∞—é‚Ä¶ –ì–æ–≤–æ—Ä—ñ—Ç—å.';
      return;
    }
    btnStart.disabled = true;
    statusEl.textContent = '–ó–∞–ø–∏—Ç –¥–æ—Å—Ç—É–ø—É –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞‚Ä¶';
    await initMic();
    if(!started){ btnStart.disabled = false; }
  });

  btnMute.addEventListener('click', () => {
    if(!started) return;
    muted = !muted;
    btnMute.textContent = muted ? '–£–≤—ñ–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫' : '–ó–∞–≥–ª—É—à–∏—Ç–∏';
    statusEl.textContent = muted ? '–ú—ñ–∫—Ä–æ—Ñ–æ–Ω –∑–∞–≥–ª—É—à–µ–Ω–æ.' : '–°–ª—É—Ö–∞—é‚Ä¶ –ì–æ–≤–æ—Ä—ñ—Ç—å.';
  });

  btnStop.addEventListener('click', () => {
    if(!started) return;
    try{
      mediaStream && mediaStream.getTracks().forEach(t => t.stop());
      audioCtx && audioCtx.close();
    }catch(e){}
    window.cancelAnimationFrame(rafId);
    started = false; muted = false;
    btnStart.disabled = false;
    btnMute.disabled = true; btnMute.textContent = '–ó–∞–≥–ª—É—à–∏—Ç–∏';
    btnStop.disabled = true;
    statusEl.textContent = '–ó—É–ø–∏–Ω–µ–Ω–æ. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å ¬´–ü–æ—á–∞—Ç–∏¬ª, —â–æ–± –∑–Ω–æ–≤—É –∞–∫—Ç–∏–≤—É–≤–∞—Ç–∏.';
    // –ú º—è–∫–∏–π –≤—ñ–¥–∫–∞—Ç –∞–Ω—ñ–º–∞—Ü—ñ–π
    orb.style.transform = `scale(1)`;
    rings.style.transform = `scale(1)`;
    rings.style.opacity = '0.6';
  });

  // –ö–ª—ñ–∫ –ø–æ —è–¥—Ä—É ‚Äî –Ω–µ–≤–µ–ª–∏—á–∫–∏–π –≤—ñ–¥—Å–∫–æ–∫
  core.addEventListener('pointerdown', () => {
    core.animate([
      { transform:'scale(1)' },
      { transform:'scale(1.04)' },
      { transform:'scale(1)' }
    ], { duration:260, easing:'cubic-bezier(.21,.7,.3,1)' });
  });

  // –ü–ª–∞–≤–Ω–∏–π –ø–∞—Ä–∞–ª–∞–∫—Å
  let px = 0, py = 0;
  window.addEventListener('pointermove', (e) => {
    const r = core.getBoundingClientRect();
    const x = (e.clientX - (r.left + r.width/2)) / r.width;
    const y = (e.clientY - (r.top + r.height/2)) / r.height;
    px = x; py = y;
    orb.style.transform += ` translate(${x*6}px, ${y*6}px)`;
  });

  // –î–æ–¥–∞—Ç–∫–æ–≤–∞ –±–µ–∑–ø–µ–∫–∞: –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è, —è–∫—â–æ –Ω–µ–º–∞—î HTTPS
  if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
    statusEl.textContent = '–î–ª—è –¥–æ—Å—Ç—É–ø—É –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞ –ø–æ—Ç—Ä—ñ–±–µ–Ω HTTPS –∞–±–æ localhost.';
  }
})();
</script>
</body>
</html>
