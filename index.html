<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jarvis UI — Neon Reactive (Optimized Mobile)</title>
<style>
  :root{
    --bg:#070a12;
    --fg:#e6f1ff;
    --fg-dim:#9bb3d1;
    --primary:#38bdf8;
    --secondary:#a78bfa;
    --accent:#22d3ee;
    --danger:#ff5470;

    --touch-size:56px;
    --control-gap:12px;
    --container-pad:20px;
    --max-core:520px;
  }

  /* Reset / base */
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: radial-gradient(1200px 800px at 50% 40%, #0d1322 0%, var(--bg) 60%, #05070c 100%);
    color:var(--fg);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
    -webkit-tap-highlight-color:transparent;
  }

  /* Backdrops (decorative) */
  .backdrop{position:fixed; inset:0; pointer-events:none; z-index:0}
  .backdrop .grid{
    position:absolute; inset:-200vmax; opacity:.06; filter:contrast(120%);
    background-image:
      linear-gradient(to right, rgba(255,255,255,.06) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(255,255,255,.06) 1px, transparent 1px);
    background-size: 56px 56px, 56px 56px;
    mask-image: radial-gradient(70% 70% at 50% 50%, #000 10%, transparent 100%);
  }
  .noise{
    position:fixed; inset:0; pointer-events:none; z-index:1; opacity:.03;
    mix-blend-mode:soft-light;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23n)"/></svg>');
  }

  /* Layout */
  .wrap{
    position:relative; z-index:2;
    height:100%; width:100%;
    display:flex; align-items:center; justify-content:center;
    padding:var(--container-pad);
  }

  /* Core area */
  .core{
    position:relative; width:min(86vw,var(--max-core)); aspect-ratio:1/1;
    display:grid; place-items:center; touch-action:none;
    max-width:var(--max-core);
  }

  /* Aura + rings + orb */
  .aura{
    position:absolute; inset:0; border-radius:50%;
    filter: blur(36px) saturate(130%);
    background:
      conic-gradient(from 0deg,
       rgba(56,189,248,.12),
       rgba(167,139,250,.10),
       rgba(34,211,238,.09),
       rgba(56,189,248,.10));
    pointer-events:none;
    will-change:transform,opacity;
  }
  .rings{
    position:absolute; inset:0; border-radius:50%; pointer-events:none;
    mix-blend-mode:screen; opacity:0.7;
    background:
      radial-gradient(closest-side, rgba(56,189,248,.08), transparent 60%),
      radial-gradient(closest-side, rgba(167,139,250,.06), transparent 58%);
    will-change:transform,opacity;
  }
  .orb{
    position:relative; width:70%; aspect-ratio:1/1; border-radius:50%;
    background:
      radial-gradient(circle at 50% 35%, rgba(255,255,255,.16), rgba(255,255,255,.02) 40%),
      radial-gradient(circle at 50% 65%, rgba(34,211,238,.22), rgba(56,189,248,.12) 45%, rgba(167,139,250,.08) 70%);
    box-shadow:
      0 0 36px rgba(56,189,248,.22),
      inset 0 0 48px rgba(167,139,250,.14);
    transition: transform .18s cubic-bezier(.2,.9,.3,1);
    display:grid; place-items:center;
    will-change:transform;
  }
  .orb::before{
    content:""; position:absolute; inset:12%; border-radius:50%;
    border:1.6px solid rgba(168,189,255,.14);
    box-shadow:0 0 20px rgba(56,189,248,.2), inset 0 0 36px rgba(56,189,248,.12);
    mask: radial-gradient(circle at 50% 50%, transparent 55%, #000 56%);
  }

  /* particles container */
  .field{
    position:absolute; inset:-6vmin; border-radius:50%; pointer-events:none;
    overflow:visible;
  }
  .particle{
    position:absolute; border-radius:50%; pointer-events:none;
    background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(56,189,248,0) 65%);
    opacity:.85; will-change:transform,opacity;
    filter:drop-shadow(0 0 6px rgba(56,189,248,.45));
  }

  /* HUD (status) */
  .hud{
    position:absolute; inset:auto 0 -92px 0;
    display:flex; flex-direction:column; align-items:center; gap:8px;
    color:var(--fg-dim); text-align:center; z-index:3;
    -webkit-user-select:none; user-select:none;
  }
  .title{ font-weight:700; letter-spacing:.12em; text-transform:uppercase; font-size:12px; color:#a6c5ff; opacity:.95; }
  .status{ font-size:clamp(15px,3.2vw,20px); font-weight:600; color:var(--fg); text-shadow:0 0 10px rgba(56,189,248,.18); }
  .hint{ font-size:13px; opacity:.8; max-width:86%; }

  /* Controls — bottom center, larger touch targets on mobile */
  .controls{
    position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
    display:flex; gap:var(--control-gap); z-index:4; align-items:center;
    padding:6px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:16px; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    box-shadow: 0 8px 26px rgba(3,7,18,.6);
  }
  .btn{
    display:inline-flex; align-items:center; justify-content:center;
    min-width:var(--touch-size); height:var(--touch-size);
    gap:8px; padding:10px 14px; border-radius:12px; border:0; outline:none;
    font-weight:700; color:var(--fg); background:linear-gradient(180deg, rgba(56,189,248,.18), rgba(56,189,248,.10));
    box-shadow: 0 10px 20px rgba(56,189,248,.14), inset 0 0 0 1px rgba(168,189,255,.08);
    cursor:pointer; user-select:none;
    transition:transform .12s ease, box-shadow .12s ease, opacity .12s ease;
  }
  .btn:active{ transform: translateY(1px); }
  .btn:focus{ box-shadow: 0 0 0 4px rgba(56,189,248,.12); border-radius:12px; }

  .btn.secondary{
    background:linear-gradient(180deg, rgba(167,139,250,.14), rgba(167,139,250,.08));
    box-shadow: 0 10px 20px rgba(167,139,250,.12), inset 0 0 0 1px rgba(168,189,255,.06);
  }
  .btn.danger{
    background:linear-gradient(180deg, rgba(255,84,112,.16), rgba(255,84,112,.06));
    box-shadow: 0 10px 20px rgba(255,84,112,.12), inset 0 0 0 1px rgba(255,84,112,.06);
  }

  .btn svg{ width:20px; height:20px; display:block; flex-shrink:0; }

  /* Accessibility hint (visually hidden) */
  .visually-hidden{ position:absolute !important; height:1px; width:1px; overflow:hidden; clip:rect(1px,1px,1px,1px); white-space:nowrap; }

  /* Canvas visuals */
  canvas#viz{ position:absolute; inset:-10% -10% -10% -10%; width:120%; height:120%; pointer-events:none; filter:blur(.4px) saturate(110%) contrast(110%); }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce){
    .aura, .rings, .orb, .particle, canvas#viz{ transition:none !important; animation:none !important; will-change:auto !important; }
  }

  /* Mobile tweaks */
  @media (max-width:640px){
    :root{ --touch-size:48px; --container-pad:14px; --control-gap:10px; }
    .hud{ inset:auto 0 -76px 0; }
    .backdrop .grid{ background-size: 40px 40px, 40px 40px; opacity:.04; }
    .orb{ width:78%; }
  }

  /* Very small screens */
  @media (max-width:420px){
    .hint{ display:none; }
    .controls{ bottom:12px; padding:4px; }
  }
</style>
</head>
<body>
  <div class="backdrop"><div class="grid"></div></div>
  <div class="noise" aria-hidden="true"></div>

  <main class="wrap" aria-live="polite">
    <section class="core" id="core" role="application" aria-label="Jarvis core visual">
      <div class="aura" id="aura" aria-hidden="true"></div>

      <canvas id="viz" aria-hidden="true"></canvas>
      <div class="rings" id="rings" aria-hidden="true"></div>

      <div class="orb" id="orb" role="img" aria-label="Reactive orb">
        <div class="field" id="field" aria-hidden="true"></div>
      </div>

      <div class="hud" aria-hidden="false">
        <div class="title">Проєкт «Jarvis» — візуальний інтерфейс</div>
        <div class="status" id="status" aria-live="polite">Готовий. Натисніть «Почати».</div>
        <div class="hint">Після дозволу на мікрофон говоріть — коло реагує на ваш голос.</div>
      </div>
    </section>
  </main>

  <div class="controls" role="toolbar" aria-label="Керування Jarvis">
    <button class="btn" id="btnStart" aria-pressed="false" title="Почати (пробіл/Enter)">
      <!-- Play icon -->
      <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M5 3v18l15-9L5 3z" fill="currentColor"/></svg>
      <span class="visually-hidden">Почати</span>
    </button>

    <button class="btn secondary" id="btnMute" disabled aria-pressed="false" title="Заглушити / Увімкнути">
      <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M16.5 12a4.5 4.5 0 0 0-4.5-4.5v9A4.5 4.5 0 0 0 16.5 12zM5 9v6h4l5 4V5L9 9H5z" fill="currentColor"/></svg>
      <span class="visually-hidden">Заглушити</span>
    </button>

    <button class="btn danger" id="btnStop" disabled title="Зупинити">
      <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><rect x="6" y="6" width="12" height="12" rx="2" fill="currentColor"/></svg>
      <span class="visually-hidden">Зупинити</span>
    </button>
  </div>

<script>
/* ============================
   Jarvis Reactive — Optimized
   ============================ */
(() => {
  // Elements
  const statusEl = document.getElementById('status');
  const orb = document.getElementById('orb');
  const rings = document.getElementById('rings');
  const core = document.getElementById('core');
  const field = document.getElementById('field');
  const btnStart = document.getElementById('btnStart');
  const btnMute = document.getElementById('btnMute');
  const btnStop = document.getElementById('btnStop');
  const canvas = document.getElementById('viz');
  const ctx = canvas.getContext('2d', { alpha: true });

  // Audio
  let audioCtx = null, analyser = null, sourceNode = null, mediaStream = null;
  let rafId = null, started = false, muted = false;

  // Visual state (avoid stacking transforms)
  let baseScale = 1;
  let translateX = 0, translateY = 0;

  // Particle config (adaptive)
  function particleCountBySize(){
    const w = window.innerWidth;
    if(w < 420) return 10;
    if(w < 640) return 18;
    if(w < 900) return 28;
    return 40;
  }

  // Seed particles
  function seedParticles(){
    field.innerHTML = '';
    const count = particleCountBySize();
    const rect = field.getBoundingClientRect();
    const cx = rect.width / 2;
    const cy = rect.height / 2;
    for(let i=0;i<count;i++){
      const p = document.createElement('div');
      p.className = 'particle';
      const angle = Math.random() * Math.PI * 2;
      const radius = (rect.width/2) * (0.68 + Math.random()*0.36);
      const x = cx + Math.cos(angle) * radius;
      const y = cy + Math.sin(angle) * radius;
      p.style.left = `${x}px`; p.style.top = `${y}px`;
      const size = Math.round(3 + Math.random()*6);
      p.style.width = p.style.height = `${size}px`;
      p.style.opacity = (0.6 + Math.random()*0.4).toFixed(2);
      // CSS variables used by animations (if active)
      p.style.setProperty('--dx', `${(Math.random()*50-25).toFixed(1)}px`);
      p.style.setProperty('--dy', `${(Math.random()*50-25).toFixed(1)}px`);
      field.appendChild(p);
    }
  }

  // Canvas fit with DPR handling, debounced
  function fitCanvas(){
    const rect = core.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * 1.2 * ratio));
    canvas.height = Math.max(1, Math.floor(rect.height * 1.2 * ratio));
  }

  let resizeTimer;
  function onResize(){
    if(resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      fitCanvas();
      seedParticles();
    }, 120);
  }
  window.addEventListener('resize', onResize, { passive:true });

  // Init visuals
  fitCanvas();
  seedParticles();

  // Audio init (called on user gesture)
  async function initMic(){
    try{
      // secure context check
      if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
        statusEl.textContent = 'Потрібен HTTPS або localhost для доступу до мікрофона.';
        statusEl.style.color = 'var(--fg-dim)';
        return false;
      }

      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true }, video:false });

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaStreamSource(mediaStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.86;
      sourceNode.connect(analyser);

      // Mobile browsers often suspend AudioContext until resumed on gesture
      if(audioCtx.state === 'suspended') await audioCtx.resume();

      statusEl.textContent = 'Слухаю… Говоріть.';
      statusEl.style.color = '';
      btnMute.disabled = false;
      btnStop.disabled = false;
      started = true;
      return true;
    }catch(err){
      statusEl.textContent = 'Помилка доступу до мікрофона: ' + (err && err.message ? err.message : err);
      statusEl.style.color = 'var(--danger)';
      return false;
    }
  }

  // RMS level calc
  let byteTimeArray = null;
  function getLevel(){
    if(!analyser){
      return 0;
    }
    if(!byteTimeArray || byteTimeArray.length !== analyser.fftSize) byteTimeArray = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(byteTimeArray);
    let sum = 0;
    for(let i=0;i<byteTimeArray.length;i++){
      const v = (byteTimeArray[i] - 128) / 128;
      sum += v*v;
    }
    return Math.sqrt(sum / byteTimeArray.length); // 0..1 (small)
  }

  // Frequency data (for spectrum)
  let freqArray = null;

  // Animation loop
  let lastTime = performance.now();
  function loop(now){
    rafId = requestAnimationFrame(loop);
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    // canvas clear
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    const cx = w/2, cy = h/2;

    // compute level with smoothing
    let level = 0;
    if(analyser && !muted){
      level = getLevel() * 3.0; // sensitivity boost
      if(level > 1) level = 1;
    }

    // apply transforms based on level and pointer translate
    baseScale = 1 + level * 0.08;
    const ringScale = 1 + level * 0.14;
    // set transforms (no concatenation)
    orb.style.transform = `translate(${translateX}px, ${translateY}px) scale(${baseScale})`;
    rings.style.transform = `translate(${translateX*0.6}px, ${translateY*0.6}px) scale(${ringScale})`;
    rings.style.opacity = String(0.6 + level * 0.4);

    // Draw neon rings (3 layers)
    const layers = 3;
    for(let i=0;i<layers;i++){
      const R = Math.min(w,h) * (0.18 + i*0.12 + level*0.04);
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.lineWidth = 2 * (window.devicePixelRatio || 1);
      const alpha = Math.max(0.02, 0.18 - i*0.03 + level*0.1);
      ctx.strokeStyle = `rgba(${160+i*20}, ${220-i*20}, 255, ${alpha})`;
      ctx.shadowColor = 'rgba(56,189,248,0.35)';
      ctx.shadowBlur = 12 * (window.devicePixelRatio || 1);
      ctx.stroke();
    }

    // Spectrum polygon (low-poly feel)
    if(analyser){
      if(!freqArray || freqArray.length !== analyser.frequencyBinCount) freqArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(freqArray);
    }
    const bins = Math.min(48, analyser ? analyser.frequencyBinCount : 48);
    const baseR = Math.min(w,h) * (0.22 + level*0.04);
    ctx.beginPath();
    for(let i=0;i<bins;i++){
      const a = (i / bins) * Math.PI * 2 + now*0.0006;
      const mag = analyser ? (freqArray[i] || 0)/255 : 0;
      const r = baseR + (mag * 32 * (window.devicePixelRatio || 1));
      const x = cx + Math.cos(a) * r;
      const y = cy + Math.sin(a) * r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle = `rgba(56,189,248, ${0.07 + level*0.10})`;
    ctx.fill();

    // Glow
    const glowR = baseR + 36 * (window.devicePixelRatio || 1) + level * 46 * (window.devicePixelRatio || 1);
    const grad = ctx.createRadialGradient(cx, cy, baseR*0.28, cx, cy, glowR);
    grad.addColorStop(0, `rgba(167,139,250, ${0.09 + level*0.14})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();

    // Small dots along ring
    const dots = 10;
    for(let i=0;i<dots;i++){
      const a = (i/dots)*Math.PI*2 + now*0.0008*(1+i*0.02);
      const r = baseR + 20*(window.devicePixelRatio || 1) + Math.sin(now*0.002 + i)*4*(window.devicePixelRatio || 1) + level*8*(window.devicePixelRatio || 1);
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      ctx.beginPath();
      ctx.arc(x,y, 2.0*(window.devicePixelRatio || 1) + level*1.2, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255, ${0.65 + Math.sin(now*0.004+i)*0.2})`;
      ctx.shadowColor = 'rgba(56,189,248,0.48)';
      ctx.shadowBlur = 10*(window.devicePixelRatio || 1);
      ctx.fill();
    }
  }

  // Start loop safely
  function startVisualLoop(){
    if(rafId) cancelAnimationFrame(rafId);
    lastTime = performance.now();
    rafId = requestAnimationFrame(loop);
  }

  // Stop visuals and audio teardown
  function stopAll(){
    if(mediaStream){
      mediaStream.getTracks().forEach(t => t.stop());
      mediaStream = null;
    }
    if(sourceNode){ try{ sourceNode.disconnect(); }catch(e){} sourceNode = null; }
    if(analyser){ analyser.disconnect(); analyser = null; }
    if(audioCtx){ try{ audioCtx.close(); }catch(e){} audioCtx = null; }
    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;
    started = false;
    muted = false;
    btnStart.disabled = false;
    btnMute.disabled = true; btnMute.setAttribute('aria-pressed', 'false');
    btnStop.disabled = true;
    statusEl.textContent = 'Зупинено. Натисніть «Почати», щоб знову активувати.';
    orb.style.transform = `translate(0px, 0px) scale(1)`;
    rings.style.transform = `translate(0px, 0px) scale(1)`;
    rings.style.opacity = '0.6';
  }

  // Button handlers
  btnStart.addEventListener('click', async (e) => {
    btnStart.disabled = true;
    statusEl.textContent = 'Запит доступу до мікрофона…';
    const ok = await initMic();
    if(ok){
      btnStart.setAttribute('aria-pressed','true');
      startVisualLoop();
    }else{
      btnStart.disabled = false;
    }
  });

  btnMute.addEventListener('click', () => {
    if(!started) return;
    muted = !muted;
    btnMute.setAttribute('aria-pressed', String(muted));
    btnMute.disabled = false;
    btnMute.querySelector('.visually-hidden').textContent = muted ? 'Увімкнути' : 'Заглушити';
    statusEl.textContent = muted ? 'Мікрофон заглушено.' : 'Слухаю… Говоріть.';
  });

  btnStop.addEventListener('click', () => {
    stopAll();
  });

  // keyboard accessibility
  window.addEventListener('keydown', (e) => {
    if(e.key === ' ' || e.key === 'Enter'){
      // if focus is not in input element, treat as play/pause start
      const tag = document.activeElement && document.activeElement.tagName;
      if(tag !== 'INPUT' && tag !== 'TEXTAREA'){
        e.preventDefault();
        if(!started) btnStart.click();
      }
    }
  }, { passive:false });

  // Pointer move for subtle parallax - optimized, throttled
  let pointerThrottle = 0;
  window.addEventListener('pointermove', (e) => {
    const now = performance.now();
    if(now - pointerThrottle < 16) return; // ~60fps cap
    pointerThrottle = now;
    const r = core.getBoundingClientRect();
    const x = (e.clientX - (r.left + r.width/2)) / r.width;
    const y = (e.clientY - (r.top + r.height/2)) / r.height;
    // scale sensitivity based on size
    const sensitivity = Math.min(20, r.width * 0.02);
    translateX = Math.round(x * sensitivity);
    translateY = Math.round(y * sensitivity);
  }, { passive:true }); || 1;
    const rect = core.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * 1.2 * ratio);
    canvas.height = Math.floor(rect.height * 1.2 * ratio);
  }

  window.addEventListener('resize', () => {
    fitCanvas();
    seedParticles(36);
  });

  fitCanvas();
  seedParticles(36);

  // Аудіо-пайплайн
  async function initMic(){
    try{
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true }, video:false });
    }catch(err){
      statusEl.textContent = 'Помилка доступу до мікрофона: ' + (err.message || err.name);
      statusEl.style.color = 'var(--danger)';
      return;
    }

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sourceNode = audioCtx.createMediaStreamSource(mediaStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.85;

    sourceNode.connect(analyser);

    // iOS requires resume on user gesture; кнопка вже була натиснута
    if(audioCtx.state === 'suspended'){
      await audioCtx.resume();
    }

    statusEl.textContent = 'Слухаю… Говоріть.';
    btnMute.disabled = false;
    btnStop.disabled = false;
    started = true;
    loop();
  }

  // Розрахунок рівня гучності (RMS)
  const dataArray = new Uint8Array(512);
  function getLevel(){
    analyser.getByteTimeDomainData(dataArray);
    // нормалізація [0..255] -> [-1..1]
    let sum = 0;
    for(let i=0; i<dataArray.length; i++){
      const v = (dataArray[i] - 128) / 128;
      sum += v*v;
    }
    const rms = Math.sqrt(sum / dataArray.length);
    return rms; // ~0..1
  }

  // Головний цикл анімацій
  let t = 0;
  function loop(){
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);

    t += 0.016;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const ratio = window.devicePixelRatio || 1;
    const w = canvas.width, h = canvas.height;
    const cx = w/2, cy = h/2;

    let level = muted ? 0 : (analyser ? getLevel() : 0);
    // Робимо реакцію трохи чутливішою
    level = Math.min(1, level * 3.2);

    // Візуал: пульсація орбіти та кілець
    const scale = 1 + level * 0.08;
    const ringPulse = 1 + level * 0.15;

    orb.style.transform = `scale(${scale})`;
    rings.style.transform = `scale(${ringPulse})`;
    rings.style.opacity = String(0.6 + level * 0.4);

    // Неонові хвилі + спектральне кільце
    const layers = 3;
    for(let i=0;i<layers;i++){
      const R = Math.min(w,h) * (0.18 + i*0.12 + level*0.05);
      ctx.beginPath();
      ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.lineWidth = 2 * ratio;
      ctx.strokeStyle = `rgba(${160+i*20}, ${220-i*20}, 255, ${0.18 - i*0.04 + level*0.12})`;
      ctx.shadowColor = 'rgba(56,189,248,0.35)';
      ctx.shadowBlur = 24 * ratio;
      ctx.stroke();
    }

    // Динамічні “пелюстки” спектру (low-poly стиль)
    const bins = 48;
    const freqData = new Uint8Array(analyser ? analyser.frequencyBinCount : 0);
    if(analyser){
      analyser.getByteFrequencyData(freqData);
    }
    const baseR = Math.min(w,h) * (0.22 + level*0.04);
    ctx.beginPath();
    for(let i=0;i<bins;i++){
      const a = (i / bins) * Math.PI * 2 + t*0.6;
      const mag = analyser ? (freqData[i] || 0)/255 : 0;
      const r = baseR + (mag * 34 * ratio);
      const x = cx + Math.cos(a) * r;
      const y = cy + Math.sin(a) * r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle = `rgba(56,189,248, ${0.08 + level*0.10})`;
    ctx.fill();

    // Світловий “дотік”
    const glowR = baseR + 40 * ratio + level * 60 * ratio;
    const grad = ctx.createRadialGradient(cx, cy, baseR*0.3, cx, cy, glowR);
    grad.addColorStop(0, `rgba(167,139,250, ${0.10 + level*0.15})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill();

    // Маленькі пульсуючі точки на кільці
    const dots = 12;
    for(let i=0;i<dots;i++){
      const a = (i/dots)*Math.PI*2 + t*(0.8 + i*0.02);
      const r = baseR + 20*ratio + Math.sin(t*1.6 + i)*6*ratio + level*10*ratio;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      ctx.beginPath();
      ctx.arc(x,y, 2.2*ratio + level*1.2, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255, ${0.7 + Math.sin(t*2+i)*0.25})`;
      ctx.shadowColor = 'rgba(56,189,248,0.55)';
      ctx.shadowBlur = 16*ratio;
      ctx.fill();
    }
  }

  // Кнопки керування
  btnStart.addEventListener('click', async () => {
    if(started){
      // Якщо аудіо-контекст заморожений (iOS), спроба відновити
      if(audioCtx && audioCtx.state === 'suspended'){ await audioCtx.resume(); }
      statusEl.textContent = 'Слухаю… Говоріть.';
      return;
    }
    btnStart.disabled = true;
    statusEl.textContent = 'Запит доступу до мікрофона…';
    await initMic();
    if(!started){ btnStart.disabled = false; }
  });

  btnMute.addEventListener('click', () => {
    if(!started) return;
    muted = !muted;
    btnMute.textContent = muted ? 'Увімкнути звук' : 'Заглушити';
    statusEl.textContent = muted ? 'Мікрофон заглушено.' : 'Слухаю… Говоріть.';
  });

  btnStop.addEventListener('click', () => {
    if(!started) return;
    try{
      mediaStream && mediaStream.getTracks().forEach(t => t.stop());
      audioCtx && audioCtx.close();
    }catch(e){}
    window.cancelAnimationFrame(rafId);
    started = false; muted = false;
    btnStart.disabled = false;
    btnMute.disabled = true; btnMute.textContent = 'Заглушити';
    btnStop.disabled = true;
    statusEl.textContent = 'Зупинено. Натисніть «Почати», щоб знову активувати.';
    // Мʼякий відкат анімацій
    orb.style.transform = `scale(1)`;
    rings.style.transform = `scale(1)`;
    rings.style.opacity = '0.6';
  });

  // Клік по ядру — невеличкий відскок
  core.addEventListener('pointerdown', () => {
    core.animate([
      { transform:'scale(1)' },
      { transform:'scale(1.04)' },
      { transform:'scale(1)' }
    ], { duration:260, easing:'cubic-bezier(.21,.7,.3,1)' });
  });

  // Плавний паралакс
  let px = 0, py = 0;
  window.addEventListener('pointermove', (e) => {
    const r = core.getBoundingClientRect();
    const x = (e.clientX - (r.left + r.width/2)) / r.width;
    const y = (e.clientY - (r.top + r.height/2)) / r.height;
    px = x; py = y;
    orb.style.transform += ` translate(${x*6}px, ${y*6}px)`;
  });

  // Додаткова безпека: попередження, якщо немає HTTPS
  if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
    statusEl.textContent = 'Для доступу до мікрофона потрібен HTTPS або localhost.';
  }
})();
</script>
</body>
</html>
